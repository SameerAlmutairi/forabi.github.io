{"html":"<h1 id=\"-javascript-\">ما الجديد في الإصدار القادم من JavaScript (الجزء الأول)</h1>\n<p>Harmony هو الاسم الرمزي للإصدار السادس من لغة ECMAScript وهي اللغة القياسية التي تقوم عليها JavaScript، والإصدار الجديد يأتي بميزات جديدة تتناول العديد من جوانب اللغة بما فيها الصياغة (syntax) وأسلوب البناء وأنواع جديدة من المكونات المدمجة في اللغة. في هذا المقال نتعرف على بعض من المميزات التي ستجعل كتابة شيفرة JavaScript أكثر اختصاراً وفعالية.</p>\n<h2 id=\"-block-scoped-variables-\">متغيرات نطاقها القطعة البرمجية (Block-scoped Variables)</h2>\n<p>في الإصدار الحالي من JavaScript، تُعامل كل المتغيرات المفروضة ضمن دالة (<code dir='ltr'>function</code>) على أنها تابعة لهذه الدالة (Function-scoped) أي يمكن الوصول إليها من أي موقع ضمن هذه الدالة، حتى وإن كانت هذه المتغيرات قد فُرضِت ضمن قطعة برمجية فرعية ضمن هذه الدالة (كحلقة <code dir='ltr'>for</code> أو جملة شرطية <code dir='ltr'>if</code>)، وهذا يخالف ما تتبناه بعض من أشهر لغات البرمجة، وقد يسبب بعض الارتباك لمن لم يعتد عليه.\nلنوضح أكثر في هذا المثال:</p>\n<pre lang='en'>\n<span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">var</span> doubles = [];\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numbers.length; i++) {\n   <span class=\"hljs-keyword\">var</span> num = numbers[i];\n   doubles[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n     <span class=\"hljs-built_in\">console</span>.log(num * <span class=\"hljs-number\">2</span>);\n   }\n}\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; doubles.length; j++) {\n  doubles[j]();\n}</pre><p>عند تنفيذ هذا المثال، سنحصل على الرقم <code dir='ltr'>6</code> ثلاث مرات، وهو أمر غير متوقع ما لم نكن على معرفة بطبيعة مجالات JavaScript، ولو طبق ما يشبه هذا المثال في لغة أخرى، لحصلنا على النتيجة <code dir='ltr'>2</code> ثم <code dir='ltr'>4</code> ثم <code dir='ltr'>6</code>، وهو ما يبدو النتيجة المنطقية لشيفرة كهذه.\nما الذي يحدث هنا؟ يتوقع المبرمج أن المتغير <code dir='ltr'>num</code> محصور ضمن حلقة <code dir='ltr'>for</code> وعليه فإن الدالة التي ندخلها في المصفوفة <code dir='ltr'>doubles</code> ستعطي عند استدعائها القيمة التي ورثتها عن مجال حلقة <code dir='ltr'>for</code> إلا أن الحقيقة هي أن المتغير <code dir='ltr'>num</code> يتبع للمجال العام، لأن حلقة <code dir='ltr'>for</code> لا تُنشئ مجالًا فرعيًّا وعليه فإن القيمة العامة <code dir='ltr'>num</code> تتغير ضمن حلقة <code dir='ltr'>for</code> من <code dir='ltr'>2</code> إلى <code dir='ltr'>4</code> إلى <code dir='ltr'>6</code> وعند استدعاء أي دالة ضمن المصفوفة <code dir='ltr'>doubles</code> فإنها ستعيد إلينا القيمة العامة <code dir='ltr'>num</code>، وبما أن الاستدعاء يحدث بعد إسناد آخر قيمة للمتغير <code dir='ltr'>num</code>، فإن قيمته في أي لحظة بعد انتهاء الحلقة الأولى ستكون آخر قيمة أسندت إليه ضمن هذه الحلقة، وهي القيمة <code dir='ltr'>6</code>.</p>\n<p>يعطينا الإصدار القادم طريقة لحل هذا الارتباك باستخدام الكلمة المفتاحية <code dir='ltr'>let</code> بدلاً عن <code dir='ltr'>var</code>، وهي تقوم بخلق مجال ضمن القطعة البرمجية التي تُستخدم فيها، بمعنى آخر: ستكون <code dir='ltr'>let</code> هي بديلنا عن <code dir='ltr'>var</code> من الآن فصاعدًا، لأنها ببساطة تعطينا النتائج البديهية التي نتوقعها. لنُعِد كتابة المثال السابق باستبدال <code dir='ltr'>var num</code> بـ<code dir='ltr'>let num</code>:</p>\n<pre lang='en'><span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">var</span> doubles = [];\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numbers.length; i++) {\n   <span class=\"hljs-keyword\">let</span> num = numbers[i];\n   doubles[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n     <span class=\"hljs-built_in\">console</span>.log(num * <span class=\"hljs-number\">2</span>);\n   }\n}\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; doubles.length; j++) {\n  doubles[j]();\n}</pre><p>عند تطبيق هذا المثال (يمكنك تطبيقه في Firefox وChrome لأن كلا المتصفحين بدأا بدعم <code dir='ltr'>let</code>) سنحصل على النتيجة البديهية <code dir='ltr'>2</code> ثم <code dir='ltr'>4</code> ثم <code dir='ltr'>6</code>. بالطبع بإمكاننا تحسين الشيفرة باعتماد <code dir='ltr'>let</code> عند التصريح عن كل المتغيرات السابقة، وهو الأمر الذي يجب أن تعتاد فعله من اليوم!</p>\n<h2 id=\"-\">شيفرة أقصر وأسهل للقراءة</h2>\n<p>لعل أكثر ما أُحبّه في JavaScript مرونتها الفائقة، وبالذات القدرة على إمرار دوال مجهولة (Anonymous Functions) لدوال أخرى، الأمر الذي يسمح لنا بكتابة شيفرة ما كان من الممكن كتابتها بلغات أخرى إلا بضعفي عدد الأسطر وربما أكثر. لاحظ هذا المثال:</p>\n<pre lang='en'><span class=\"hljs-keyword\">var</span> people = [<span class=\"hljs-string\">&apos;Ahmed&apos;</span>, <span class=\"hljs-string\">&apos;Samer&apos;</span>, <span class=\"hljs-string\">&apos;Khaled&apos;</span>];\n<span class=\"hljs-keyword\">var</span> greetings = people.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(person)</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&apos;Hello &apos;</span> + person + <span class=\"hljs-string\">&apos;!&apos;</span>; });\n\n<span class=\"hljs-built_in\">console</span>.log(greetings); <span class=\"hljs-comment\" dir=\"ltr\">// [&apos;Hello Ahmed!&apos;, &apos;Hello Samer!&apos;, &apos;Hello Khaled!&apos;];</span></pre><p>لو أردنا تنفيذ هذه المهمة في لغة أخرى، فلربما احتجنا إلى حلقة <code dir='ltr'>for</code> لنمرّ من خلالها على كل عنصر ضمن المصفوفة ثم إدخال العبارات الجديدة ضمن مصفوفة أخرى، وهذا يعني أن مهمة يمكن كتابتها بسطرين في JavaScript قد تتطلب 5 سطور في لغة أخرى. لو لم تمتلك JavaScript القدرة على إمرار الدالة المجهولة <code dir='ltr'>function(person) {...}</code> أعلاه، لفقدت جزءًا كبيرة من مرونتها.</p>\n<p>لكن الإصدار القادم من JavaScript تذهب أبعد من ذلك، وتختصر علينا كتابة الكثير من النص البرمجي. لُنعد كتابة المثال السابق:</p>\n<pre lang='en'><span class=\"hljs-keyword\">let</span> people = [<span class=\"hljs-string\">&apos;Ahmed&apos;</span>, <span class=\"hljs-string\">&apos;Samer&apos;</span>, <span class=\"hljs-string\">&apos;Khaled&apos;</span>];\n<span class=\"hljs-keyword\">let</span> greetings = people.map(person =&gt; <span class=\"hljs-string\">&apos;Hello &apos;</span> + person + <span class=\"hljs-string\">&apos;!&apos;</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(greetings); <span class=\"hljs-comment\" dir=\"ltr\">// [&apos;Hello Ahmed!&apos;, &apos;Hello Samer!&apos;, &apos;Hello Khaled!&apos;];</span></pre><p>في هذا المثال استخدمنا ما اصطلح على تسميته <strong>دوال الأسهم (Arrow Functions)</strong>، وهي طريقة أكثر اختصارًا لكتابة الدوال المجهولة، لن تحتاج لكتابة <code dir='ltr'>return</code>، فهي ستضاف تلقائيًا عند التنفيذ. من الآن فصاعداً اعتمد دوال الأسهم عندما تريد تنفيذ دالة مجهولة بسيطة بسطر واحد.</p>\n<p>بمناسبة الحديث عن الشيفرة المختصرة... ما رأيكم لو جعلنا الشيفرة أعلاه <em>أكثر اختصارًا</em>؟!</p>\n<pre lang='en'><span class=\"hljs-keyword\">let</span> people = [<span class=\"hljs-string\">&apos;Ahmed&apos;</span>, <span class=\"hljs-string\">&apos;Samer&apos;</span>, <span class=\"hljs-string\">&apos;Khaled&apos;</span>];\n<span class=\"hljs-keyword\">let</span> greetings = [<span class=\"hljs-string\">&apos;Hello &apos;</span> + person + <span class=\"hljs-string\">&apos;!&apos;</span> <span class=\"hljs-keyword\">for</span> (person of people)];\n\n<span class=\"hljs-built_in\">console</span>.log(greetings); <span class=\"hljs-comment\" dir=\"ltr\">// [&apos;Hello Ahmed!&apos;, &apos;Hello Samer!&apos;, &apos;Hello Khaled!&apos;];</span></pre><p>قد تبدو الصياغة غريبة بعض الشيء، لكنها تتيح لنا فهم النص بسهولة أكبر، وتغنينا عن الحاجة لدالة مجهولة (الأمر الذي قد يؤثر على الأداء، وإن كان بأجزاء من الثواني). الصياغة التي استخدمناها أعلاه تُسمى <strong>Array Comprehensions</strong>، وإن كنت قادرًا على ترجمتها إلى العربية بطريقة واضحة، فلا تبخل بها علينا!</p>\n<p>لكن... ألا ترون أنه يمكن تحسين هذه الشيفرة قليلاً؟</p>\n<pre lang='en'><span class=\"hljs-keyword\">let</span> people = [<span class=\"hljs-string\">&apos;Ahmed&apos;</span>, <span class=\"hljs-string\">&apos;Samer&apos;</span>, <span class=\"hljs-string\">&apos;Khaled&apos;</span>];\n<span class=\"hljs-keyword\">let</span> greetings = [`Hello ${ person }!` <span class=\"hljs-keyword\">for</span> (person of people)];\n\n<span class=\"hljs-built_in\">console</span>.log(greetings); <span class=\"hljs-comment\" dir=\"ltr\">// [&apos;Hello Ahmed!&apos;, &apos;Hello Samer!&apos;, &apos;Hello Khaled!&apos;];</span></pre><p>هنا استبدلنا إشارات الاقتباس (<code dir='ltr'>&#39;</code> أو <code dir='ltr'>&quot;</code>) بالإشارة ` الأمر الذي أتاح لنا إحاطة المتغير <code dir='ltr'>person</code> بقوسين معكوفين مسبوقين بإشارة <code dir='ltr'>$</code>، وهذه الصياغة تدعى <strong>&quot;السلاسل النصية المقولبة&quot;</strong> أو Template Strings، والتي تسمح -بالإضافة إلى القولبة- بالعديد من الأشياء الرائعة، كالعبارات على عدة أسطر:</p>\n<pre lang='en'><span class=\"hljs-keyword\">let</span> multilineString = `I am\na multiline\nstring`;\n\n<span class=\"hljs-built_in\">console</span>.log(multilineString);\n<span class=\"hljs-comment\" dir=\"ltr\">// I am</span>\n<span class=\"hljs-comment\" dir=\"ltr\">// a multiline</span>\n<span class=\"hljs-comment\" dir=\"ltr\">// string</span></pre><p><del>للأسف لن تعمل الشفرة السابقة في أي من المتصفحات الحالية، لأن السلاسل النصية المقولبة ما تزال غير معتمدة ضمن أي منها</del>. <strong>تحديث:</strong> <a href=\"http://firefoxnightly.tumblr.com/post/92234218909/ecmascript-6-template-strings-are-now-supported-in\">بدأ Firefox Nightly باعتمادها</a>.</p>\n<p>من المميزات الجديدة كذلك إمكانية اختصار بناء الكائنات ذات الخصائص بالشكل التالي:</p>\n<ul>\n<li><p>حاليًا، نقوم بكتابة شيفرة مثل هذه:</p>\n<pre lang='en'><span class=\"hljs-keyword\">var</span> createPerson = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name, age, location)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    name: name,\n    age: age,\n    location: location,\n    greet: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;Hello, I am &apos;</span> + name + <span class=\"hljs-string\">&apos; from &apos;</span> + location + <span class=\"hljs-string\">&apos;. I am &apos;</span> + age + <span class=\"hljs-string\">&apos;.&apos;</span>);\n    }\n  }\n};\n\n<span class=\"hljs-keyword\">var</span> fawwaz = createPerson(<span class=\"hljs-string\">&apos;Fawwaz&apos;</span>, <span class=\"hljs-number\">21</span>, <span class=\"hljs-string\">&apos;Syria&apos;</span>);\n<span class=\"hljs-built_in\">console</span>.log(fawwaz.name); <span class=\"hljs-comment\" dir=\"ltr\">// &apos;Fawwaz&apos;</span>\nfawwaz.greet(); <span class=\"hljs-comment\" dir=\"ltr\">// &quot;Hello, I am Fawwaz from Syria. I am 21.&quot;</span></pre></li>\n<li><p>في الإصدار القادم، سيكون بالإمكان كتابة الشيفرة كالتالي:</p>\n<pre lang='en'><span class=\"hljs-keyword\">let</span> createPerson = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(name, age, location)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    name,\n    age,\n    location,\n    greet() {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;Hello, I am &apos;</span> + name + <span class=\"hljs-string\">&apos; from &apos;</span> + location + <span class=\"hljs-string\">&apos;. I am &apos;</span> + age + <span class=\"hljs-string\">&apos;.&apos;</span>);\n    }\n  }\n};\n\n<span class=\"hljs-keyword\">let</span> fawwaz = createPerson(<span class=\"hljs-string\">&apos;Fawwaz&apos;</span>, <span class=\"hljs-number\">21</span>, <span class=\"hljs-string\">&apos;Syria&apos;</span>);\n<span class=\"hljs-built_in\">console</span>.log(fawwaz.name); <span class=\"hljs-comment\" dir=\"ltr\">// &apos;Fawwaz&apos;</span>\nfawwaz.greet(); <span class=\"hljs-comment\" dir=\"ltr\">// &quot;Hello, I am Fawwaz from Syria. I am 21.&quot;</span></pre></li>\n</ul>\n<p>بما أن اسم المُعامل (parameter) يماثل اسم الخاصة (property)، فإن هذا يتم تفسيره على أن قيمة الخاصة توافق قيمة المعامل، بمعنى: <code dir='ltr'>name: name</code>، بالإضافة إلى كتابة <code dir='ltr'>greet() {...}</code> بدل <code dir='ltr'>greet: function() {...}</code>.</p>\n<p>كذلك سيكون بإمكاننا تحسين هذا النص أكثر من ذلك باستخدام <strong>الأصناف (Classes)</strong>، نعم! سيكون لدينا أصناف أخيرًا! (سنستعرضها لاحقاً)</p>\n<h2 id=\"-constants-\">الثوابت (Constants)</h2>\n<p>سيداتي وسادتي... رحبوا بالثوابت... نعم إنها أخيرًا متوفرة في JavaScript، إحدى المكونات الأساسية لأي لغة برمجية التي لم تكن متوفرة في JavaScript، أصبحت الآن متوفرة. والآن نأتي للسؤال البديهي: لماذا أحتاج للثوابت؟ أليس بإمكاني التصريح عن متغير دون أن أغير قيمته بعد إعطاءه القيمة الأولية؟ نعم بالطبع بإمكانك ذلك، لكن هذا لا يعني بالضرورة أن المستخدم أو نصاً برمجيًا من طرف ثالث ليس بإمكانه تغيير قيمة هذا المتغير في سياق التنفيذ، وطالما أن المتغير &quot;متغير&quot; بطبيعته، فإننا دومًا بحاجة إلى شيء من أصل اللغة يحمينا من تغييره خطأ. عند التصريح عن ثابت فإننا نعطيه قيمة أولية ثم ستتولى الآلة البرمجية لـJavaScript حماية هذا الثابت من التغيير، وسُيرمى خطأ عند محاولة إسناد قيمة جديدة لهذا الثابت.</p>\n<pre lang='en'><span class=\"hljs-keyword\">const</span> myConstant = <span class=\"hljs-string\">&apos;Never change this!&apos;</span>;\n\nmyConstant = <span class=\"hljs-string\">&apos;Trying to change your constant&apos;</span>;\n<span class=\"hljs-comment\" dir=\"ltr\">// TypeError: redeclaration of const myConstant</span>\n\n<span class=\"hljs-built_in\">console</span>.log(myConstant); <span class=\"hljs-comment\" dir=\"ltr\">// &quot;Never change this!&quot;</span></pre><h2 id=\"-default-parameters-\">المُعاملات الافتراضية (Default Parameters)</h2>\n<p>غياب دعم المُعاملات الافتراضية في JavaScript واحد من أكثر الأشياء التي تزعجني، لأنها تجبرني على كتابة شيفرة مثل هذه:</p>\n<pre lang='en'><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SayHello</span> <span class=\"hljs-params\">(user)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> user == <span class=\"hljs-string\">&apos;undefined&apos;</span>) {\n    user = <span class=\"hljs-string\">&apos;User&apos;</span>;\n  }\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;Hello &apos;</span> + user);\n}\n\n<span class=\"hljs-built_in\">console</span>.log(SayHello(<span class=\"hljs-string\">&apos;Fawwaz&apos;</span>)); <span class=\"hljs-comment\" dir=\"ltr\">// Hello Fawwaz!</span>\n<span class=\"hljs-built_in\">console</span>.log(SayHello()); <span class=\"hljs-comment\" dir=\"ltr\">// Hello User!</span></pre><p>لو كان عندي 3 متغيرات غير إجبارية، فهذا يعني أنني سأحتاج 3 جمل شرطية، الأمر الذي يتطلب الكثير من الكتابة المُملة. بفضل الإصدار القادم من JavaScript، سيكون بالإمكان كتابة شيفرة أبسط بكثير:</p>\n<pre lang='en'><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SayHello</span> <span class=\"hljs-params\">(user=&apos;User&apos;)</span> </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;Hello &apos;</span> + user);\n}\n\nSayHello(<span class=\"hljs-string\">&apos;Fawwaz&apos;</span>); <span class=\"hljs-comment\" dir=\"ltr\">// Hello Fawwaz!</span>\nSayHello(); <span class=\"hljs-comment\" dir=\"ltr\">// Hello User!</span></pre><h2 id=\"-promises-\">الوعود (Promises)</h2>\n<p>الوعود هي الحل الذي تأتينا به JavaScript لحل مشكلة هرم الموت (Pyramid of Death) الذي نواجهه عند تنفيذ مهمات غير متزامنة تعتمد إحداها على الأخرى:</p>\n<pre lang='en'><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFullPost</span><span class=\"hljs-params\">(url, callback)</span> </span>{\n\n  <span class=\"hljs-keyword\">var</span> getAuthor = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(post, callback)</span> </span>{\n    $.ajax({ method: <span class=\"hljs-string\">&apos;GET&apos;</span>, url: <span class=\"hljs-string\">&apos;/author/&apos;</span> + post.author_id }, callback);\n  };\n\n  <span class=\"hljs-keyword\">var</span> getRelatedPosts = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(post, callback)</span> </span>{\n    $.ajax({ method: <span class=\"hljs-string\">&apos;GET&apos;</span>, url: <span class=\"hljs-string\">&apos;/related/&apos;</span> + post.id }, callback);\n  };\n\n  $.ajax({ method: <span class=\"hljs-string\">&apos;GET&apos;</span>, url: url }, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(post)</span> </span>{\n    getAuthor(post, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(res)</span> </span>{\n      post.author = res.data.author;\n      getRelatedPosts(post, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(res)</span> </span>{\n        post.releated = res.data.releated;\n        callback(post);\n      });\n    });\n  });\n\n}</pre><p>هل تلاحظ أن الشيفرة تتجه نحو اليمين؟ لو أردنا تنفيذ هذه المهمات غير المتزامنة واحدة بعد الأخرى وكان عددها 10 مثلًا فستصبح الشيفرة شديدة التعقيد، كما أن هذه الطريقة ليست بديهية، ولا يمكن لك أن تفهم ماذا تفعل هذه الدالة المجهولة (المعامل الثاني في كل دالة) ما لم تألفها. ماذا لو أمكننا كتابة هذه الشيفرة بصورة أفضل؟</p>\n<pre lang='en'><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFullPost</span><span class=\"hljs-params\">(url)</span> </span>{\n  <span class=\"hljs-keyword\">var</span> post = { };\n  <span class=\"hljs-keyword\">var</span> getPost = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(url)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> $http.get(url);\n  };\n\n  <span class=\"hljs-keyword\">var</span> getAuthor = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(post)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> $http.get(<span class=\"hljs-string\">&apos;/author/&apos;</span> + post.author_id).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(res)</span> </span>{\n      post.author = res.data.author;\n    });\n  };\n\n  <span class=\"hljs-keyword\">var</span> getRelatedPosts = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(post)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> $http.get(<span class=\"hljs-string\">&apos;/related/&apos;</span> + post.id).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(res)</span> </span>{\n        post.related = res.data.related;\n    });\n  };\n\n  <span class=\"hljs-keyword\">return</span> getPost().then(getAuthor).then(getRelatedPosts).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(err)</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;We got an error:&apos;</span>, err);\n  });\n}</pre><p>في الجزء القادم سنتعرّف على المكوّنات الجديدة الأكثر إثارة، كالمولّدات التي ستجعلنا نغير من طريقة تعاملنا مع البيانات اللامتزامنة كليًّا!</p>\n","title":"ما الجديد في الإصدار القادم من JavaScript (الجزء الأول)","filename":"whats-new-in-es6.json","id":"whats-new-in-es6","date":"2014-05-28T00:00:00.000Z","image":null,"description":"Harmony هو الاسم الرمزي للإصدار السادس من لغة ECMAScript وهي اللغة القياسية التي تقوم عليها JavaScript، والإصدار الجديد يأتي بميزات جديدة تتناول العديد من جوانب اللغة بما فيها الصياغة (syntax) وأسلوب البناء وأنواع جديدة من المكونات المدمجة في اللغة. في هذا المقال نتعرف على بعض من المميزات التي ستجعل كتابة شيفرة JavaScript أكثر اختصاراً وفعالية.","images":0,"videos":0,"tracks":0,"links":1,"type":"text"}