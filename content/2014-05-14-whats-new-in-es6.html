<h1 id="-javascript">ما الجديد في الإصدار القادم من JavaScript</h1>
<p>Harmony هو الاسم الرمزي للإصدار السادس من لغة ECMAScript وهي اللغة القياسية التي تقوم عليها JavaScript، والإصدار الجديد يأتي بميزات جديدة تتناول العديد من جوانب اللغة بما فيها الصياغة (syntax) وأسلوب البناء وأنواع جديدة من المكونات المدمجة في اللغة. في هذا المقال نتعرف على بعض من المميزات التي ستجعل كتابة شيفرة JavaScript أكثر اختصاراً وفعالية.</p>
<h2 id="-block-scoped-variables-">متغيرات نطاقها القطعة البرمجية (Block-scoped Variables)</h2>
<p>في الإصدار الحالي من JavaScript، تُعامل كل المتغيرات المفروضة ضمن دالة (<code>function</code>) على أنها تابعة لهذه الدالة (Function-scoped) أي يمكن الوصول إليها من أي موقع ضمن هذه الدالة، حتى وإن كانت هذه المتغيرات قد فُرضِت ضمن قطعة برمجية فرعية ضمن هذه الدالة (كحلقة <code>for</code> أو جملة شرطية <code>if</code>)، وهذا يخالف ما تتبناه بعض من أشهر لغات البرمجة، وقد يسبب بعض الارتباك لمن لم يعتد عليه.
لنوضح أكثر في هذا المثال:</p>
<pre><code class="lang-javascript">
var numbers = <span class="hljs-matrix">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span>;
var doubles = <span class="hljs-matrix">[]</span>;

<span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-transposed_variable">numbers.</span><span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{
   var num = numbers[i];
   doubles[i] = function() {
     console.log(num * <span class="hljs-number">2</span>);
   }</span>
}

<span class="hljs-keyword">for</span> (var <span class="hljs-built_in">j</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">j</span> &lt; <span class="hljs-transposed_variable">doubles.</span><span class="hljs-built_in">length</span>; <span class="hljs-built_in">j</span>++) <span class="hljs-cell">{
  doubles[j]();
}</span>
</code></pre>
<p>عند تنفيذ هذا المثال، سنحصل على الرقم <code>6</code> ثلاث مرات، وهو أمر غير متوقع ما لم نكن على معرفة بطبيعة مجالات JavaScript، ولو طبق ما يشبه هذا المثال في لغة أخرى، لحصلنا على النتيجة <code>2</code> ثم <code>4</code> ثم <code>6</code>، وهو ما يبدو النتيجة المنطقية لشيفرة كهذه.
ما الذي يحدث هنا؟ يتوقع المبرمج أن المتغير <code>num</code> محصور ضمن حلقة <code>for</code> وعليه فإن الدالة التي ندخلها في المصفوفة <code>doubles</code> ستعطي عند استدعائها القيمة التي ورثتها عن مجال حلقة <code>for</code> إلا أن الحقيقة هي أن المتغير <code>num</code> يتبع للمجال العام، لأن حلقة <code>for</code> لا تُنشئ مجالًا فرعيًّا وعليه فإن القيمة العامة <code>num</code> تتغير ضمن حلقة <code>for</code> من <code>2</code> إلى <code>4</code> إلى <code>6</code> وعند استدعاء أي دالة ضمن المصفوفة <code>doubles</code> فإنها ستعيد إلينا القيمة العامة <code>num</code>، وبما أن الاستدعاء يحدث بعد إسناد آخر قيمة للمتغير <code>num</code>، فإن قيمته في أي لحظة بعد انتهاء الحلقة الأولى ستكون آخر قيمة أسندت إليه ضمن هذه الحلقة، وهي القيمة <code>6</code>.</p>
<p>يعطينا الإصدار القادم طريقة لحل هذا الارتباك باستخدام الكلمة المفتاحية <code>let</code> بدلاً عن <code>var</code>، وهي تقوم بخلق مجال ضمن القطعة البرمجية التي تُستخدم فيها، بمعنى آخر: ستكون <code>let</code> هي بديلنا عن <code>var</code> من الآن فصاعدًا، لأنها ببساطة تعطينا النتائج البديهية التي نتوقعها. لنُعِد كتابة المثال السابق باستبدال <code>var num</code> بـ<code>let num</code>:</p>
<pre><code class="lang-javascript">var numbers = <span class="hljs-matrix">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span>;
var doubles = <span class="hljs-matrix">[]</span>;

<span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-transposed_variable">numbers.</span><span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{
   let num = numbers[i];
   doubles[i] = function() {
     console.log(num * <span class="hljs-number">2</span>);
   }</span>
}

<span class="hljs-keyword">for</span> (var <span class="hljs-built_in">j</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">j</span> &lt; <span class="hljs-transposed_variable">doubles.</span><span class="hljs-built_in">length</span>; <span class="hljs-built_in">j</span>++) <span class="hljs-cell">{
  doubles[j]();
}</span>
</code></pre>
<p>عند تطبيق هذا المثال (يمكنك تطبيقه في Firefox وChrome لأن كلا المتصفحين بدأا بدعم <code>let</code>) سنحصل على النتيجة البديهية <code>2</code> ثم <code>4</code> ثم <code>6</code>. بالطبع بإمكاننا تحسين الشيفرة باعتماد <code>let</code> عند التصريح عن كل المتغيرات السابقة، وهو الأمر الذي يجب أن تعتاد فعله من اليوم!</p>
<h2 id="-">شيفرة أقصر وأسهل للقراءة</h2>
<p>لعل أكثر ما أُحبّه في JavaScript مرونتها الفائقة، وبالذات القدرة على إمرار دوال مجهولة (Anonymous Functions) لدوال أخرى، الأمر الذي يسمح لنا بكتابة شيفرة ما كان من الممكن كتابتها بلغات أخرى إلا بضعفي عدد الأسطر وربما أكثر. لاحظ هذا المثال:</p>
<pre><code class="lang-javascript"><span class="hljs-reserved">var</span> people = [<span class="hljs-string">'Ahmed'</span>, <span class="hljs-string">'Samer'</span>, <span class="hljs-string">'Khaled'</span>];
<span class="hljs-reserved">var</span> greetings = people.map(<span class="hljs-reserved">function</span>(person) { <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + person + <span class="hljs-string">'!'</span>; });

<span class="hljs-built_in">console</span>.log(greetings); <span class="hljs-regexp">//</span> [<span class="hljs-string">'Hello Ahmed!'</span>, <span class="hljs-string">'Hello Samer!'</span>, <span class="hljs-string">'Hello Khaled!'</span>];
</code></pre>
<p>لو أردنا تنفيذ هذه المهمة في لغة أخرى، فلربما احتجنا إلى حلقة <code>for</code> لنمرّ من خلالها على كل عنصر ضمن المصفوفة ثم إدخال العبارات الجديدة ضمن مصفوفة أخرى، وهذا يعني أن مهمة يمكن كتابتها بسطرين في JavaScript قد تتطلب 5 سطور في لغة أخرى. لو لم تمتلك JavaScript القدرة على إمرار الدالة المجهولة <code>function(person) {...}</code> أعلاه، لفقدت جزءًا كبيرة من مرونتها.</p>
<p>لكن الإصدار القادم من JavaScript تذهب أبعد من ذلك، وتختصر علينا كتابة الكثير من النص البرمجي. لُنعد كتابة المثال السابق:</p>
<pre><code class="lang-javascript"><span class="hljs-reserved">let</span> people = [<span class="hljs-string">'Ahmed'</span>, <span class="hljs-string">'Samer'</span>, <span class="hljs-string">'Khaled'</span>];
<span class="hljs-reserved">let</span> greetings = people.map(person<span class="hljs-function"> =&gt;</span> <span class="hljs-string">'Hello '</span> + person + <span class="hljs-string">'!'</span>);

<span class="hljs-built_in">console</span>.log(greetings); <span class="hljs-regexp">//</span> [<span class="hljs-string">'Hello Ahmed!'</span>, <span class="hljs-string">'Hello Samer!'</span>, <span class="hljs-string">'Hello Khaled!'</span>];
</code></pre>
<p>في هذا المثال استخدمنا ما اصطلح على تسميته <strong>دوال الأسهم (Arrow Functions)</strong>، وهي طريقة أكثر اختصارًا لكتابة الدوال المجهولة، لن تحتاج لكتابة <code>return</code>، فهي ستضاف تلقائيًا عند التنفيذ. من الآن فصاعداً اعتمد دوال الأسهم عندما تريد تنفيذ دالة مجهولة بسيطة بسطر واحد.</p>
<p>بمناسبة الحديث عن الشيفرة المختصرة... ما رأيكم لو جعلنا الشيفرة أعلاه <em>أكثر اختصارًا</em>؟!</p>
<pre><code class="lang-javascript"><span class="hljs-reserved">let</span> people = [<span class="hljs-string">'Ahmed'</span>, <span class="hljs-string">'Samer'</span>, <span class="hljs-string">'Khaled'</span>];
<span class="hljs-reserved">let</span> greetings = [<span class="hljs-string">'Hello '</span> + person + <span class="hljs-string">'!'</span> <span class="hljs-keyword">for</span> (person <span class="hljs-keyword">of</span> people)];

<span class="hljs-built_in">console</span>.log(greetings); <span class="hljs-regexp">//</span> [<span class="hljs-string">'Hello Ahmed!'</span>, <span class="hljs-string">'Hello Samer!'</span>, <span class="hljs-string">'Hello Khaled!'</span>];
</code></pre>
<p>قد تبدو الصياغة غريبة بعض الشيء، لكنها تتيح لنا فهم النص بسهولة أكبر، وتغنينا عن الحاجة لدالة مجهولة (الأمر الذي قد يؤثر على الأداء، وإن كان بأجزاء من الثواني). الصياغة التي استخدمناها أعلاه تُسمى <strong>Array Comprehensions</strong>، وإن كنت قادرًا على ترجمتها إلى العربية بطريقة واضحة، فلا تبخل بها علينا!</p>
<p>لكن... ألا ترون أنه يمكن تحسين هذه الشيفرة قليلاً؟</p>
<pre><code class="lang-javascript"><span class="hljs-reserved">let</span> people = [<span class="hljs-string">'Ahmed'</span>, <span class="hljs-string">'Samer'</span>, <span class="hljs-string">'Khaled'</span>];
<span class="hljs-reserved">let</span> greetings = [`<span class="javascript">Hello ${ person }!</span>` <span class="hljs-keyword">for</span> (person <span class="hljs-keyword">of</span> people)];

<span class="hljs-built_in">console</span>.log(greetings); <span class="hljs-regexp">//</span> [<span class="hljs-string">'Hello Ahmed!'</span>, <span class="hljs-string">'Hello Samer!'</span>, <span class="hljs-string">'Hello Khaled!'</span>];
</code></pre>
<p>هنا استبدلنا إشارات الاقتباس (<code>&#39;</code> أو <code>&quot;</code>) بالإشارة ` الأمر الذي أتاح لنا إحاطة المتغير <code>person</code> بقوسين معكوفين مسبوقين بإشارة <code>$</code>، وهذه الصياغة تدعى <strong>&quot;السلاسل النصية المقولبة&quot;</strong> أو Template Strings، والتي تسمح -بالإضافة إلى القولبة- بالعديد من الأشياء الرائعة، كالعبارات على عدة أسطر:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> multilineString <span class="hljs-subst">=</span> <span class="hljs-string">`I am
a multiline
string`</span>;

console<span class="hljs-built_in">.</span><span class="hljs-keyword">log</span>(multilineString);
<span class="hljs-comment">// I am</span>
<span class="hljs-comment">// a multiline</span>
<span class="hljs-comment">// string</span>
</code></pre>
<p>للأسف لن تعمل الشفرة السابقة في أي من المتصفحات الحالية، لأن السلاسل النصية المقولبة ما تزال غير معتمدة ضمن أي منها.</p>
<p>من المميزات الجديدة كذلك إمكانية اختصار بناء الكائنات ذات الخصائص بالشكل التالي:</p>
<ul>
<li><p>حاليًا، نقوم بكتابة شيفرة مثل هذه:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> createPerson = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, age, location)</span> {</span>
  <span class="hljs-keyword">return</span> {
    name: name,
    age: age,
    location: location,
    greet: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      console.log(<span class="hljs-string">'Hello, I am '</span> + name + <span class="hljs-string">' from '</span> + location + <span class="hljs-string">'. I am '</span> + age + <span class="hljs-string">'.'</span>);
    }
  }
};

<span class="hljs-keyword">var</span> fawwaz = createPerson(<span class="hljs-string">'Fawwaz'</span>, <span class="hljs-number">21</span>, <span class="hljs-string">'Syria'</span>);
console.log(fawwaz.name); <span class="hljs-comment">// 'Fawwaz'</span>
fawwaz.greet(); <span class="hljs-comment">// "Hello, I am Fawwaz from Syria. I am 21."</span>
</code></pre>
</li>
<li><p>في الإصدار القادم، سيكون بالإمكان كتابة الشيفرة كالتالي:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> createPerson = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, age, location)</span> {</span>
  <span class="hljs-keyword">return</span> {
    name,
    age,
    location,
    greet() {
      console.log(<span class="hljs-string">'Hello, I am '</span> + name + <span class="hljs-string">' from '</span> + location + <span class="hljs-string">'. I am '</span> + age + <span class="hljs-string">'.'</span>);
    }
  }
};

<span class="hljs-keyword">let</span> fawwaz = createPerson(<span class="hljs-string">'Fawwaz'</span>, <span class="hljs-number">21</span>, <span class="hljs-string">'Syria'</span>);
console.log(fawwaz.name); <span class="hljs-comment">// 'Fawwaz'</span>
fawwaz.greet(); <span class="hljs-comment">// "Hello, I am Fawwaz from Syria. I am 21."</span>
</code></pre>
</li>
</ul>
<p>بما أن اسم المُعامل (parameter) يماثل اسم الخاصة (property)، فإن هذا يتم تفسيره على أن قيمة الخاصة توافق قيمة المعامل، بمعنى: <code>name: name</code>، بالإضافة إلى كتابة <code>greet() {...}</code> بدل <code>greet: function() {...}</code>.</p>
<p>كذلك سيكون بإمكاننا تحسين هذا النص أكثر من ذلك باستخدام <strong>الأصناف (Classes)</strong>، نعم! سيكون لدينا أصناف أخيرًا! (سنستعرضها لاحقاً)</p>
<h2 id="-constants-">الثوابت (Constants)</h2>
<p>سيداتي وسادتي... رحبوا بالثوابت... نعم إنها أخيرًا متوفرة في JavaScript، إحدى المكونات الأساسية لأي لغة برمجية التي لم تكن متوفرة في JavaScript، أصبحت الآن متوفرة. والآن نأتي للسؤال البديهي: لماذا أحتاج للثوابت؟ أليس بإمكاني التصريح عن متغير دون أن أغير قيمته بعد إعطاءه القيمة الأولية؟ نعم بالطبع بإمكانك ذلك، لكن هذا لا يعني بالضرورة أن المستخدم أو نصاً برمجيًا من طرف ثالث ليس بإمكانه تغيير قيمة هذا المتغير في سياق التنفيذ، وطالما أن المتغير &quot;متغير&quot; بطبيعته، فإننا دومًا بحاجة إلى شيء من أصل اللغة يحمينا من تغييره خطأ. عند التصريح عن ثابت فإننا نعطيه قيمة أولية ثم ستتولى الآلة البرمجية لـJavaScript حماية هذا الثابت من التغيير، وسُيرمى خطأ عند محاولة إسناد قيمة جديدة لهذا الثابت.</p>
<pre><code class="lang-javascript"><span class="hljs-reserved">const</span> myConstant = <span class="hljs-string">'Never change this!'</span>;

myConstant = <span class="hljs-string">'Trying to change your constant'</span>;
<span class="hljs-regexp">//</span> <span class="hljs-attribute">TypeError</span>: redeclaration <span class="hljs-keyword">of</span> <span class="hljs-reserved">const</span> myConstant

<span class="hljs-built_in">console</span>.log(myConstant); <span class="hljs-regexp">//</span> <span class="hljs-string">"Never change this!"</span>
</code></pre>
<h2 id="-default-parameters-">المُعاملات الافتراضية (Default Parameters)</h2>
<p>غياب دعم المُعاملات الافتراضية في JavaScript واحد من أكثر الأشياء التي تزعجني، لأنها تجبرني على كتابة شيفرة مثل هذه:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayHello</span> <span class="hljs-params">(user)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> user == <span class="hljs-string">'undefined'</span>) {
    user = <span class="hljs-string">'User'</span>;
  }

  console.log(<span class="hljs-string">'Hello '</span> + user);
}

console.log(SayHello(<span class="hljs-string">'Fawwaz'</span>)); <span class="hljs-comment">// Hello Fawwaz!</span>
console.log(SayHello()); <span class="hljs-comment">// Hello User!</span>
</code></pre>
<p>لو كان عندي 3 متغيرات غير إجبارية، فهذا يعني أنني سأحتاج 3 جمل شرطية، الأمر الذي يتطلب الكثير من الكتابة المُملة. بفضل الإصدار القادم من JavaScript، سيكون بالإمكان كتابة شيفرة أبسط بكثير:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayHello</span> <span class="hljs-params">(user=<span class="hljs-string">'User'</span>)</span> {</span>
  console.log(<span class="hljs-string">'Hello '</span> + user);
}

SayHello(<span class="hljs-string">'Fawwaz'</span>); <span class="hljs-comment">// Hello Fawwaz!</span>
SayHello(); <span class="hljs-comment">// Hello User!</span>
</code></pre>
<h2 id="-this-"><code>this</code> القاموسية</h2>
<h2 id="-generators-">المُولِّدات (Generators)</h2>
<p>المولدات ببساطة هي دوال يمكن إيقافها والعودة إليها في وقت لاحق مع الاحتفاظ بسياقها دون تغيير، صياغة المولدات لا تختلف كثيرًا عن صياغة الدوال التقليدية، كل ما عليك هو إضافة إشارة * بعد <code>function</code> واستخدام <code>yield</code> بدل <code>return</code>، المثال التالي سيوضح فكرة المولدات أكثر:</p>
<pre><code class="lang-javascript">function* getName() {
  let names = [<span class="hljs-string">'Muhammad'</span>, <span class="hljs-string">'Salem'</span>, <span class="hljs-string">'Abdullah'</span>];
  <span class="hljs-keyword">for</span> (name of names) {
    <span class="hljs-keyword">yield</span> name;
  }
}

let myGenerator = getName();
myGenerator.<span class="hljs-keyword">next</span>().value; <span class="hljs-regexp">//</span> <span class="hljs-string">'Muhammad'</span>
myGenerator.<span class="hljs-keyword">next</span>().value; <span class="hljs-regexp">//</span> <span class="hljs-string">'Salem'</span>
myGenerator.<span class="hljs-keyword">next</span>().value; <span class="hljs-regexp">//</span> <span class="hljs-string">'Abdullah'</span>
myGenerator.<span class="hljs-keyword">next</span>().value; <span class="hljs-regexp">//</span> undefined

}
</code></pre>
<p>ما الذي يحدث هنا؟ فرضنا مولّدًا سمّيناه <code>getName</code>، وفيه صرحنا عن مصفوفة فيها أسماء، وظيفة هذا المولد أن يعطينا الأسماء بالترتيب في كل مرة نستدعيه فيها ليعطينا النتيجة التالية (<code>next()</code>)، أولاً يجب حفظ نسخة عن المولّد ضمن متغير لكي نسمح لها بحفظ حالتها، ودون ذلك سيعطينا استدعاء المولد مباشرة <code>getName().next()</code> دوماً النتيجة الأولى لأننا عملياً نُنشئ نسخة جديدة عنه في كل مرة نستدعيه، أما استدعاء نسخة عنه وحفظها في متغير مثل <code>myGenerator</code> فيسمح لنا باستدعاء <code>.next()</code> عليها كما هو متوقع. لا ترجع الدالة <code>.next()</code> القيمة التي نرسلها عبر <code>yield</code> فقط، بل ترجع كائناً يحوي القيمة المطلوبة ضمن الخاصة <code>value</code>، وخاصة أخرى <code>done</code> تسمح لنا بمعرفة ما إذا كان المولد قد أعطانا كل شيء (يجب استدعاء <code>next()</code> مرة واحدة زائدة عن العدد الذي نتوقعه للحصول على <code>done</code> بقيمة <code>true</code>، لأنه لا يمكن منطقيًا معرفة ما إذا أنهى المولّد عمله في الخطوة التي تسبق الخطوة الأخيرة - أليس كذلك؟).</p>
<p>تبدو المولدات فكرة جميلة... وهي تسهل عمل مُكررات دون الحاجة لتلويث النطاق بمتغيرات مثل هذه:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> names = [<span class="hljs-string">'Muhammad'</span>, <span class="hljs-string">'Salem'</span>, <span class="hljs-string">'Abdullah'</span>];
  i++;
  <span class="hljs-keyword">return</span> names[i];
}

getName(); <span class="hljs-comment">// 'Muhammad'</span>
getName(); <span class="hljs-comment">// 'Salem'</span>
getName(); <span class="hljs-comment">// 'Abdullah'</span>
getName(); <span class="hljs-comment">// undefined</span>
</code></pre>
<p>ترتيب أكثر للشيفرة، ولكن ما الفائدة <em>الحقيقية</em> للمولدات؟ هل حزرتها؟ نعم... <strong>المهمات غير المتزامنة (Asynchronus Tasks)</strong>! لحظة... ما العلاقة بين هذه وتلك؟</p>
<p>لنلقِ نظرة... لنفترض أنني أريد جلب بيانات من الخادم..</p>
<pre><code class="lang-javascript">$.ajax(<span class="hljs-string">'http'</span>)
<span class="hljs-comment">// TODO</span>
</code></pre>
<h2 id="-iterators-">المُكرِّرات (Iterators)</h2>
<h2 id="-rest-spread-">البقيّة (Rest) والناشرة (Spread)</h2>
<h2 id="-destructuring">التفكيك Destructuring</h2>
<h2 id="-for-of-">حلقة <code>for... of</code></h2>
<h2 id="-modules-">الوحدات (Modules)</h2>
<h2 id="-classes-">الأصناف (Classes)</h2>
<h2 id="-set-map-weakmap">أشباه المصفوفات Set وMap وWeakMap</h2>
<h2 id="-promises-">الوعود (Promises)</h2>
<p>الوعود هي الحل الذي تأتينا به JavaScript لحل مشكلة هرم الموت (Pyramid of Death) الذي نواجهه عند تنفيذ مهمات غير متزامنة تعتمد إحداها على الأخرى:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFullPost</span><span class="hljs-params">(url, callback)</span> {</span>

  <span class="hljs-keyword">var</span> getAuthor = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(post, callback)</span> {</span>
    $.ajax({ method: <span class="hljs-string">'GET'</span>, url: <span class="hljs-string">'/author/'</span> + post.author_id }, callback);
  };

  <span class="hljs-keyword">var</span> getRelatedPosts = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(post, callback)</span> {</span>
    $.ajax({ method: <span class="hljs-string">'GET'</span>, url: <span class="hljs-string">'/related/'</span> + post.id }, callback);
  };

  $.ajax({ method: <span class="hljs-string">'GET'</span>, url: url }, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(post)</span> {</span>
    getAuthor(post, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span> {</span>
      post.author = res.data.author;
      getRelatedPosts(post, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span> {</span>
        post.releated = res.data.releated;
        callback(post);
      });
    });
  });

}
</code></pre>
<p>هل تلاحظ أن الشيفرة تتجه نحو اليمين؟ لو أردنا تنفيذ هذه المهمات غير المتزامنة واحدة بعد الأخرى وكان عددها 10 مثلًا فستصبح الشيفرة شديدة التعقيد، كما أن هذه الطريقة ليست بديهية، ولا يمكن لك أن تفهم ماذا تفعل هذه الدالة المجهولة (المعامل الثاني في كل دالة) ما لم تألفها. ماذا لو أمكننا كتابة هذه الشيفرة بصورة أفضل؟</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFullPost</span><span class="hljs-params">(url)</span> {</span>
  <span class="hljs-keyword">var</span> post = { };
  <span class="hljs-keyword">var</span> getPost = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(url)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$http</span>.get(url);
  };

  <span class="hljs-keyword">var</span> getAuthor = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(post)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$http</span>.get(<span class="hljs-string">'/author/'</span> + post.author_id).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span> {</span>
      post.author = res.data.author;
    });
  };

  <span class="hljs-keyword">var</span> getRelatedPosts = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(post)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$http</span>.get(<span class="hljs-string">'/related/'</span> + post.id).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span> {</span>
        post.related = res.data.related;
    });
  };

  <span class="hljs-keyword">return</span> getPost().then(getAuthor).then(getRelatedPosts).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> {</span>
    console.log(<span class="hljs-string">'We got an error:'</span>, err);
  });
}
</code></pre>
<h2 id="-proxies-">المُفوّضات (Proxies)</h2>
